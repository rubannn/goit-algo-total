# Тема 9. Жадібні алгоритми та динамічне програмування

Необхідно написати дві функції для касової системи, яка видає решту покупцеві:

1. Функція жадібного алгоритму `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми `113` це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

2. Функція динамічного програмування `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми `113` це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

> Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл `readme.md` домашнього завдання.

---
---
## Порівняння алгоритмів видачі решти

## Опис

У цьому проекті реалізовано два алгоритми для видачі решти:

- `find_coins_greedy` — жадібний алгоритм, що на кожному кроці вибирає найбільшу доступну монету.
- `find_min_coins` — динамічне програмування, що знаходить мінімальну кількість монет.

## Результати тестування

Тести проводилися з використанням модуля `timeit`, кожен алгоритм запускався по 100 разів для кожного значення суми.

| Тестове значення | find_coins_greedy (сек) | find_min_coins (сек) |
| ---------------- | ----------------------- | -------------------- |
| 100              | 0.000139                | 0.012102             |
| 432              | 0.000107                | 0.052425             |
| 999              | 0.000114                | 0.130617             |
| 1500             | 0.000087                | 0.273399             |
| 3000             | 0.000109                | 0.461216             |
| 5000             | 0.000104                | 0.730463             |

> *Примітка: значення часу зміняться залежно від конкретної машини та середовища виконання.*

## Висновки

- *Жадібний алгоритм (`find_coins_greedy`)* є надзвичайно швидким, але не гарантує мінімальної кількості монет для довільного набору номіналів (у нашому випадку номінали дозволяють це).
- *Алгоритм динамічного програмування (`find_min_coins`)* знаходить оптимальне рішення, але працює значно повільніше, особливо на великих сумах.

### Рекомендація:

- Якщо важлива *швидкість* — використовувати `find_coins_greedy`.
- Якщо важлива *оптимальність рішень* (наприклад, інший набір монет) — використовувати `find_min_coins`.
